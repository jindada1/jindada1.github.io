<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>操作系统 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="概述知识储备系统软件包括：操作系统，数据库管理系统，语言处理程序，服务性程序，标准库程序 并发和共享是操作系统最基本的特征：两者相互依存 BIOS是一组固化到计算机主板上的一个ROM芯片里的程序，是计算机的开启时运行的第一个程序，主要功能是为计算机提供最底层的、最直接的硬件设置和控制。 OS提供的接口1：联机和脱机两种命令接口，其中  脱机：类似于批处理程序，一次性写好一次性执行 联机：命令行，输">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://example.com/posts/operating-system/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="概述知识储备系统软件包括：操作系统，数据库管理系统，语言处理程序，服务性程序，标准库程序 并发和共享是操作系统最基本的特征：两者相互依存 BIOS是一组固化到计算机主板上的一个ROM芯片里的程序，是计算机的开启时运行的第一个程序，主要功能是为计算机提供最底层的、最直接的硬件设置和控制。 OS提供的接口1：联机和脱机两种命令接口，其中  脱机：类似于批处理程序，一次性写好一次性执行 联机：命令行，输">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/posts/operating-system/20190706002405844.jpg">
<meta property="og:image" content="http://example.com/posts/operating-system/1575361736973.png">
<meta property="og:image" content="http://example.com/posts/operating-system/1575372756493.png">
<meta property="og:image" content="http://example.com/posts/operating-system/1575370452737.png">
<meta property="og:image" content="http://example.com/posts/operating-system/1575374982183.png">
<meta property="og:image" content="http://example.com/posts/operating-system/1575375028443.png">
<meta property="og:image" content="http://example.com/posts/operating-system/1575463704209.png">
<meta property="og:image" content="http://example.com/posts/operating-system/image-20191210190654239.png">
<meta property="article:published_time" content="2021-01-12T09:33:01.000Z">
<meta property="article:modified_time" content="2021-01-12T15:28:47.889Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="408 计算机基础综合 考研 OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/posts/operating-system/20190706002405844.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-operating-system" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/posts/operating-system/" class="article-date">
  <time class="dt-published" datetime="2021-01-12T09:33:01.000Z" itemprop="datePublished">2021-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      操作系统
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h3><p>系统软件包括：操作系统，数据库管理系统，语言处理程序，服务性程序，标准库程序</p>
<p>并发和共享是操作系统最基本的特征：两者相互依存</p>
<p>BIOS是一组固化到计算机主板上的一个ROM芯片里的程序，是计算机的开启时运行的第一个程序，主要功能是为计算机提供最底层的、最直接的硬件设置和控制。</p>
<h3 id="OS提供的接口"><a href="#OS提供的接口" class="headerlink" title="OS提供的接口"></a>OS提供的接口</h3><p>1：联机和脱机两种命令接口，其中</p>
<ul>
<li>脱机：类似于批处理程序，一次性写好一次性执行</li>
<li>联机：命令行，输入一句执行一句，涉及到【命令解释器】和【shell】</li>
</ul>
<p>2：提供给程序的接口叫【系统调用】，又叫【广义指令】</p>
<h3 id="发展，类型"><a href="#发展，类型" class="headerlink" title="发展，类型"></a>发展，类型</h3><p>单道批处理：最简单串行</p>
<p>多道批处理：中断技术，并发执行，吞吐量高，但不能交互，用户响应时间长</p>
<p>分时操作系统：多个用户同时使用一台计算机，能够人机交互（剥夺式调度进程）</p>
<p>实时操作系统：在严格时限内处理完任务（及时性），可靠性</p>
<hr>
<p>【例】与单道程序系统相比，多道程序系统的优点是</p>
<p>系统开销小（错误：需要额外的开销来组织，调度作业</p>
<p>IO设备利用率高（√）</p>
<hr>
<p>【例】采用（优先级+非抢占式调度算法）来缩短分时系统的系统响应时间</p>
<p>优先级：使得重要的作业能及时响应</p>
<p>非抢占：不重要的作业也不会因为被抢占而迟迟不能处理完毕</p>
<hr>
<p>【例】多任务操作系统具有并发和并行的特点（√，并发执行进程；CPU与IO并行，CPU与通道并行）</p>
<h3 id="核心-用户态"><a href="#核心-用户态" class="headerlink" title="核心/用户态"></a>核心/用户态</h3><p>CPU执行不同权限指令时的状态</p>
<p><strong>核心态</strong>：特权指令</p>
<ul>
<li>I/O指令</li>
<li>置中断指令</li>
<li>存取用于内存保护的寄存器的指令</li>
<li>送程序状态字到寄存器的指令</li>
<li>与硬件关联紧密的模块<ul>
<li>时钟管理：处理和时间有关的信息，比如系统时间、进程时间片、延迟、CPU使用时间、各种定时器</li>
<li>中断处理程序</li>
<li>设备驱动</li>
</ul>
</li>
<li>运行频率较高的程序<ul>
<li>进程管理程序</li>
<li>存储器管理程序</li>
<li>设备管理程序</li>
<li>原语：原子操作指令，不可被中断的（执行原语是会关闭中断功能）</li>
</ul>
</li>
</ul>
<p><strong>用户态</strong></p>
<ul>
<li>命令解释程序</li>
<li>调用系统调用</li>
<li>发生缺页</li>
<li>发生外部中断</li>
</ul>
<p>用户态进入核心态是通过<strong>中断和异常</strong>，这一过程由【硬件】完成；由核心态返回用户态是【操作系统】完成的</p>
<ul>
<li><p>中断：也叫【外中断】</p>
<ul>
<li>时间片中断</li>
<li>IO结束中断</li>
</ul>
</li>
<li><p>异常：也叫【内中断】，源自CPU执行的指令产生的错误，不能被屏蔽，一旦出现要立即处理，处理要依赖当前程序的运行现场</p>
<ul>
<li>地址越界</li>
<li>虚存缺页</li>
<li>专门的“陷入”指令，访管指令或 trap 指令</li>
</ul>
</li>
</ul>
<p><strong>系统调用的执行过程</strong>：用户进程传递系统调用参数，通过 trap 指令主动让权给内核（进入内核态）这样产生的中断叫【访管中断】，将返回地址压入堆栈，执行被调用的内核服务程序，完后恢复程序现场返回用户态</p>
<p>用户态进入核心态后，使用的堆栈也由用户堆栈切换为系统堆栈，但系统堆栈属于该进程</p>
<hr>
<p>【例】中断处理程序保存：<u>程序的断点（PC），程序状态字寄存器（PSW）</u>，子程序调用需保存：<u>程序的断点（PC）</u>，外部中断处理过程中，PC值由中断隐指令自动保存，操作系统保存：<u>通用寄存器</u>。</p>
<hr>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程相关概念"><a href="#进程相关概念" class="headerlink" title="进程相关概念"></a>进程相关概念</h3><p>进程实体=程序段+相关数据段+PCB（进程控制块）</p>
<p>进程控制用的程序段是【原语】</p>
<p><strong>状态</strong></p>
<p>创建过程：</p>
<ol>
<li>OS分配进程标识符PID，申请PCB，如果申请失败，则进程创建失败</li>
<li>复制父进程的环境</li>
<li>分配资源（堆栈，文件…），如果分配失败进程处于阻塞态/等待态</li>
<li>复制父进程空间里的内容</li>
<li>将进程设置为就绪状态，放入就绪队列</li>
</ol>
<p>就绪态：进程已经获得了除了处理机之外的一切所需资源，一旦得到处理机后就可以运行</p>
<p>运行态：在单处理机环境下，创建了N个进程，每一时刻最多只有N-1个进程处于就绪状态，最多有 1 个处于运行态，最少有 0 个处于运行态（比如死锁导致全部阻塞）</p>
<p>阻塞态：进程正在等待某一事件（某种资源的获取、IO…）而暂停运行</p>
<p>终止过程：</p>
<ol>
<li>根据终止进程的进程标识符，检索PCB，查看进程状态</li>
<li>若该进程有子进程则全部递归终止（即使正在运行也立即终止</li>
<li>将该进程的所属资源还给父进程或者OS</li>
<li>将该进程的PCB从PCB集合中移除</li>
</ol>
<p><strong>异常终止</strong>：存储区越界；保护错；非法指令；特权指令错；I/O故障等</p>
<p><strong>状态转换</strong></p>
<p><img src="/posts/operating-system/20190706002405844.jpg" alt="在这里插入图片描述"></p>
<p>就绪态→运行态：被调度，进程切换</p>
<ul>
<li>保存CPU上下文，包括程序计数器和其它寄存器</li>
<li>更新PCB信息，并将PCB移入就绪或等待队列</li>
<li>通过调度算法选择另一个进程，更新PCB并执行</li>
<li>更新内存管理的数据结构</li>
<li>恢复处理及上下文</li>
</ul>
<p>运行态→就绪态：运行时间片结束；可剥夺的操作系统中被更高优先权进程抢占</p>
<p>运行态→阻塞态：等待某一资源（如外设）或某一事件发生（如I/O操作完成）系统调用中断【主动行为，自己调用Block原语，即只有正在占有CPU的进程才能转换成阻塞态】</p>
<ul>
<li>检索PCB</li>
<li>保护现场，更改状态，停止运行</li>
<li>将该PCB插入相应事件的等待队列</li>
</ul>
<p>阻塞态→就绪态：I/O操作结束，中断结束【被动的，需要其它进程协助，中断处理程序把进程变成就绪态，调用Wakeup原语】</p>
<ul>
<li>检索PCB</li>
<li>把PCB从该事件的等待队列移出</li>
<li>插入就绪队列，等待被调度</li>
</ul>
<hr>
<p>【例】就绪队列不空，就绪的进程数目越多，CPU的效率<u>不变</u>（只要就绪队列不空，CPU总是可以调度进程并运行，与就绪队列的大小无关）</p>
<p>【例】以下需要创建新进程的是</p>
<ul>
<li>设备分配【×】在系统中设置相应的数据结构即可，不需要启动进程</li>
<li>用户登录【√】开机的时候登陆账户，要启动用户桌面、配置用户环境等</li>
</ul>
<hr>
<p><strong>进程控制块</strong>：由系统维护，常驻内存，系统中的PCB数量是有限的，有两种组织形式</p>
<ul>
<li>链接：同一状态的PCB链接成一个队列，阻塞状态由于阻塞原因不同会有多条队列</li>
<li>索引：同一状态的PCB在一个索引表里</li>
</ul>
<hr>
<p>【例】若一个进程实体由</p>
<p>B：共享正文段</p>
<p>C：数据堆段</p>
<p>D：数据栈段</p>
<p>四部分组成，则下列C语言程序中的数据位于哪一部分</p>
<p>未赋值的局部变量（D）</p>
<p>调用函数传递的实参（D）</p>
<p>malloc 动态分配的区域（C）</p>
<p>const 常量（B）</p>
<p>全局变量（B）</p>
<p>二进制代码（B）</p>
<hr>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>用户进程空间是独立的，进程间不能直接相互访问对方的进程空间</p>
<p><strong>共享存储</strong>：通过特殊的系统调用，对共享的空间进行读写，这个过程中需要借助同步/互斥工具（P，V操作）</p>
<ul>
<li>低级方式：基于数据结构的共享</li>
<li>高级方式：基于存储区的共享</li>
</ul>
<p><strong>消息传递</strong>：由系统提供发送，接收两个原语来传递格式化的信息</p>
<ul>
<li>直接通信：发送进程直接把消息挂在接收进程的消息缓冲队列上，等待接收进程取</li>
<li>间接通信：发送进程把消息发给中间实体（信箱），接收进程从信箱取信息</li>
</ul>
<p><strong>管道</strong>：用于连接一个读进程和写进程的固定大小的共享文件（pipe文件/缓冲区），视为共享存储的优化</p>
<ul>
<li>是一种半双工通信，一次只能一个方向</li>
<li>当缓冲区为空，才写入，写满时写操作阻塞</li>
<li>当缓冲区满了，才读出，数据被读取就从缓冲区中删除，所以读完数据缓冲区变空，继续写操作</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>同属一个进程的线程共享该进程所有资源，线程之间可以相互创建撤销，通信不需要操作系统干预</p>
<p>线程是：CPU执行的基本单元，程序执行流的最小单元，独立调度的基本单位，拥有自己的CPU现场</p>
<p>进程是：除了CPU外系统资源分配的基本单元</p>
<p>线程也有【线程控制块】一个进程的多个线程分布在多个CPU上同时执行可以加快进程执行速度</p>
<p><strong>分类</strong></p>
<p>用户级线程：应用程序自己维护，内核不管</p>
<p>内核级线程：由内核进行调度维护的</p>
<p><strong>模型</strong></p>
<ul>
<li><p>多对一：多个用户级线程映射到一个内核级线程，线程管理在用户空间进行，效率较高，但当一个线程使用内核服务时被阻塞会导致整个进程阻塞，同时这多个用户线程并不能并行在多核CPU上</p>
</li>
<li><p>一对一：并发强，但开销大，会影响程序性能</p>
</li>
<li>多对多：M 个用户级线程映射到 m 个内核级线程（M≥m），集前两者之所长，优点多</li>
</ul>
<hr>
<p>【例】系统动态dll库的系统线程，被不同进程调用时，它们是（相同）的线程</p>
<p>（同一个系统线程可以由系统调用被多个不同进程多次调用）</p>
<p>【例】降低进程优先级的合理时机是</p>
<p>A：时间片用完【√】降低优先级让其它进程被调度执行</p>
<p>B：进程刚完成I/O操作，进入就绪队列（为了让其尽快处理I/O结果应该提高优先级）</p>
<p>C：进程长期处于就绪队列（为了防止饥饿现象应该提高优先级）</p>
<p>D：进程从就绪态转为运行态（运行态的进程不应变动优先级）</p>
<p>【例】父进程创建子进程与主程序调用子程序有什么不同？</p>
<p>答：父子进程可以并发执行，而主程序要停在调用原点，子程序开始执行，返回结果后，主程序再继续执行</p>
<hr>
<h3 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h3><p><strong>作业的三级调度</strong></p>
<ul>
<li>作业调度：又叫高级调度，从外存上处于后备状态的作业中挑选一个，为其分配内存及各种资源，建立相应的进程。本质上是内存与辅存之间的调度，每个作业只调入一次，调出一次。</li>
<li>中级调度：又叫内存调度，将暂时不能运行的进程调至外存【挂起】，直到内存或资源满足运行需要后再调回内存，改状态为【就绪】</li>
<li>进程调度：又叫低级调度，分配CPU给就绪进程，频率最高<ul>
<li>在以下条件下不能进行调度<ul>
<li>中断处理过程中</li>
<li>进程处于操作系统内核程序的临界区中</li>
<li>进行原子操作时</li>
</ul>
</li>
<li>在以下条件下能调度<ul>
<li>进程处于临界区中：有些临界区（比如打印机I/O）只要不破坏临界区访问规则，就可以进行调度</li>
<li>当前程序无法进行，或时间片终止（非剥夺式）</li>
<li>中断/trap处理结束后，置请求调度标志，则可不恢复到原进程，立即调度（剥夺式）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>性能指标</strong></p>
<p>等待时间：作业在就绪队列中等待的时间，是衡量调度算法优劣的性能指标</p>
<p>周转时间：= 作业完成时刻 - 作业提交时刻，是一个总时间，影响因素很多</p>
<p>响应时间：= 首次产生响应的时刻 - 用户提交请求的时刻，是交互式系统关心的指标</p>
<p>系统吞吐量：单位时间完成的作业数量，短作业更有优势</p>
<hr>
<p>【例】某系统进程调度和进程切换总开销为 1μs，某时刻就绪队列有一个进程，相关信息如下，求该进程的周转时间</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>进程</th>
<th>等待时间/μs</th>
<th>需要的CPU时间/μs</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td>30</td>
<td>12</td>
</tr>
</tbody>
</table>
</div>
<p>答：1 + 30 + 12</p>
<p>这里要说的是，考研中，从这一时刻开始，意味着初始的调度时间也要算进去，所以最前面有一个 1 别忘了</p>
<hr>
<p><strong>调度算法</strong></p>
<ul>
<li><p>先来先服务（FCFS）：（进程&amp;作业调度）</p>
<ul>
<li>有利于CPU繁忙型的作业和长作业</li>
<li>不利于IO繁忙型的作业和短作业</li>
</ul>
</li>
<li><p>短作业优先（SJF）：（进程&amp;作业调度）</p>
<ul>
<li>平均等待时间，平均周转时间最少</li>
<li>长作业迟迟得不到调度会饥饿</li>
</ul>
</li>
<li><p>优先级调度：（进程&amp;作业调度）</p>
<ul>
<li>动态/静态优先级</li>
<li>剥夺/非剥夺</li>
<li>优先级高低排序：系统进程＞用户进程；交互型＞非交互型；I/O型＞计算型</li>
</ul>
</li>
<li><p>高响应比优先：对SJF和FCFS综合平衡</p>
<script type="math/tex; mode=display">
  响应比R_p=\frac{等待时间+要求服务的时间}{要求服务的时间}</script><ul>
<li>当等待时间相同时，短进程优先</li>
<li>当进程长短一样时，先来的优先，克服饥饿</li>
</ul>
</li>
<li><p>时间片轮转：每次结束一个时间片就切换进程，剥夺式的</p>
<ul>
<li>若时间片很大，每个进程在一个时间片内都能完成，就退化成FCFS</li>
</ul>
</li>
<li><p>多级反馈队列：（究极融合版）动态调整进程优先级和时间片大小</p>
<ul>
<li>第一级：FCFS，优先级最高，时间片最短</li>
<li>第二级：FCFS</li>
<li>··· ···</li>
<li>第 n 级：时间片轮转</li>
<li>新进程进入内存，首先放在第一级队列末尾，如果一个时间片没完成，就降到第二级，以此类推逐级下降</li>
<li>当第 i 级队列全部执行完毕，才执行第 i+1 级，若 i &gt; 1且此时有新进程进到第一级，则新进程抢占CPU</li>
</ul>
</li>
</ul>
<h3 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h3><p><strong>临界资源</strong>：一次只能被一个进程使用的资源</p>
<p><strong>临界区</strong>：进程中访问临界资源的代码</p>
<p>基本原则</p>
<ul>
<li>空闲让进：临界区空闲时，进程想进就进</li>
<li>忙则等待：临界区被占有时，其它想进来的进程必须等待</li>
<li>让权等待：在等待临界区的进程，就不要再占有CPU了，防止忙等待</li>
<li>有限等待：等临界区的进程也不能等太久，必须要在有限时间内进入临界区</li>
</ul>
<p><strong>软件实现法</strong></p>
<ul>
<li><p>单标志位：用一个 turn 标记允许进入临界区的进程号</p>
<ul>
<li>turn = 1，P1进入，随后 turn = 0，但此时 P0 并不想进入，而 P1 也被挡在外面。违背了空闲让进</li>
</ul>
</li>
<li><p>双标志位先检查：两个进程都先检查对方的占有标志位，如果对方不占有，再把自己的占有位设为 true</p>
<ul>
<li>两个进程在占有前同时检查，都发现对方不在，然后一起进入。违背了忙则等待</li>
</ul>
</li>
<li><p>双标志位后检查：两个进程都先把自己的占有位设为 true，再检查对方的占有位，如果对方不占有就进入</p>
<ul>
<li>两个进程在检查前同时设置自己的占有位，结果检查的时候都发现对方正在占有，于是无限等待。导致饥饿，违背了有限等待</li>
</ul>
</li>
<li><p>Peterson：使用 turn 来解决饥饿现象，使用 flag 来实现互斥访问</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Pi进程*/</span></span><br><span class="line">flag[i] = <span class="literal">true</span>;</span><br><span class="line">turn = j;</span><br><span class="line"><span class="keyword">while</span>(flag[j] &amp;&amp; turn = j);</span><br><span class="line">critical section;</span><br><span class="line">flag[i] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Pj进程*/</span></span><br><span class="line">flag[j] = <span class="literal">true</span>;</span><br><span class="line">turn = i;</span><br><span class="line"><span class="keyword">while</span>(flag[i] &amp;&amp; turn = i);</span><br><span class="line">critical section;</span><br><span class="line">flag[j] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>甲：我来啦 flag[甲] = true；乙：我来啦 flag[乙] = true</li>
<li>乙：你先 turn = 甲</li>
<li>甲：你先 turn = 乙</li>
<li>乙：好的我先【精髓是只让一次，先让者先用】</li>
<li>甲等待中 while(flag[乙] &amp;&amp; turn = 乙);</li>
<li>乙：我好了 flag[乙] = false</li>
<li>甲：我来了 while 循环跳出</li>
</ul>
</li>
</ul>
<p><strong>硬件实现方法</strong></p>
<ul>
<li><p>关中断：简单粗暴，没有中断进程就不切换，用户程序具有控制中断的能力是一件很恐怖的事情，整个系统都会无法运行</p>
</li>
<li><p>硬件指令法：原语指令，由硬件逻辑实现，不被中断</p>
<ul>
<li><p>TestAndSet(&amp;lock)：读出 lock 的当前值，并把 lock 设置为 true；即正在占用，又叫 TSL(&amp;lock)</p>
  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while TestAndSet(&amp;lock)； // 检查临界段的标志位 lock，初值为 false</span><br></pre></td></tr></table></figure></li>
<li><p>Swap(&amp;lock, &amp;key)：交换两个字节的内容</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(key != <span class="literal">false</span>)</span><br><span class="line">    Swap(&amp;lock, &amp;key);	<span class="comment">// 用于捕捉 lock = flase 的一瞬间</span></span><br></pre></td></tr></table></figure></li>
<li><p>缺点一：注意到进程在等待时，while循环里，依然在耗费CPU，处于忙等待状态，违背了让权等待</p>
</li>
<li><p>缺点二：进程只有在被调度进CPU后，才能执行它的while，如果进程一直不被调度，就饥饿了</p>
</li>
</ul>
</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>注意到前述互斥访问临界区时，处于等待状态的进程主动 check while 循环条件，换句话说，处于等待状态的进程还会被CPU执行，占有CPU资源。有没有什么办法能让它们不被调度，然后当它们的临界区空闲后，有一个程序再去唤醒等待这个临界资源的进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;		   <span class="comment">// 该临界资源的数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span> <span class="comment">// 正在等待该临界资源的进程链表</span></span><br><span class="line">&#125; semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P 操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">    S.value --;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt; <span class="number">0</span>)&#123;</span><br><span class="line">     	add <span class="keyword">this</span> process to S.L;<span class="comment">// 尾部</span></span><br><span class="line">    	block(S.L); 	<span class="comment">// 主动让权</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V 操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">    S.value ++;</span><br><span class="line">    <span class="keyword">if</span>(S.value &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">     	remove head process P from S.L;<span class="comment">// 首部，FIFO</span></span><br><span class="line">    	wakeup(P); 	<span class="comment">// 唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信号量的值，即 S.value 在 &gt; 0 时，就是可用资源的数量，在 ≤ 0 时，是正在等待该资源的进程数量</p>
<p>一个进程对某一信号量进行 P 操作后进入临界区，退出临界区后，依然是该进程进行 V 操作</p>
<p><strong>PV操作的伪码</strong></p>
<p>关键：设置信号量，并赋值</p>
<ul>
<li>找到互斥点，设置相应的互斥信号量 mutex，初值必为 1；或数组 semaphore chopstick[5] = {1, 1, 1, 1, 1}</li>
<li>设置资源数量信号量，semaphore empty = n；semaphore full = 0</li>
</ul>
<p><strong>读者-写者问题</strong></p>
<blockquote>
<p>描述：一组读进程和一组写进程，写进程与写进程互斥，写进程与读进程互斥，读进程之间可以共享文件</p>
<p>设计一个读写公平的程序</p>
</blockquote>
<p>思考</p>
<ul>
<li>首先对于写进程，互斥就完事儿了，需要一个 rw</li>
<li>对于读进程，要考虑本身进程与写进程的互斥，还要考虑本身进程与其它读进程的共享，不能我自己读完了就可以把控制权交给写进程，还要看看此时还有没有其它读进程在读，当读进程的数量为 0 时，才能移交控制权。所以需要设置一个计数变量 count，用于统计读进程数</li>
<li>对于这个计数变量的操作，为了保证计数的正确性，也要设置一个互斥信号 mutex</li>
</ul>
<p>伪码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">S mutex = <span class="number">1</span>;</span><br><span class="line">S rw = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">writer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(rw);			<span class="comment">// 读写互斥</span></span><br><span class="line">        write;</span><br><span class="line">        V(rw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)	<span class="comment">// 第一个读进程锁上读写互斥信号</span></span><br><span class="line">            P(rw);</span><br><span class="line">        count++;		<span class="comment">// 读进程进场的标志</span></span><br><span class="line">        V(mutex);</span><br><span class="line">        </span><br><span class="line">        read;</span><br><span class="line">        </span><br><span class="line">        P(mutex);</span><br><span class="line">        count--;		<span class="comment">// 读进程退场的标志</span></span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)	<span class="comment">// 最后一个读进程释放读写互斥信号</span></span><br><span class="line">            V(rw);</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到目前为止，确实能正常工作，但存在一个问题，即当有一个进程在读的时候，所有的写进程都会等待，哪怕是先来的写进程，而其它后到的读进程可以自由读取。如果有源源不断的读进程，那么写进程会”饿死“，不符合”读-写公平“的原则。</p>
<p>所以要做到当文件正在被读/写时，下一个访问文件的进程应该按照先来后到的顺序，读进程先来那么就读，写进程先来就写，还需要一个互斥信号量表示”下一个访问权在我手里“ next = 1，先来的进程，P 掉 next</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">S mutex = <span class="number">1</span>;</span><br><span class="line">S rw = <span class="number">1</span>;</span><br><span class="line">S next = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">writer()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(next)		<span class="comment">// 手握下一个访问权</span></span><br><span class="line">        P(rw);</span><br><span class="line">        write;</span><br><span class="line">        V(rw);</span><br><span class="line">        V(next)		<span class="comment">// 放出下一个访问权</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(next)		<span class="comment">// 手握下一个访问权，如果没握住就等，握住了才能有count++表示成功进场</span></span><br><span class="line">        P(mutex);</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">            P(rw);</span><br><span class="line">        count++;</span><br><span class="line">        V(mutex);</span><br><span class="line">        V(next)		<span class="comment">// 放出下一个访问权</span></span><br><span class="line">        </span><br><span class="line">        read;</span><br><span class="line">        </span><br><span class="line">        P(mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">            V(rw);</span><br><span class="line">        V(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>管程</strong></p>
<p>是：一组数据以及对这组数据的操作组成的软件模块，封装了同步/互斥操作，对进程隐蔽了同步细节，简化了同步功能的调用接口。使编写并发程序和写串行一样简便</p>
<p>提出的背景：</p>
<p>信号量机制的缺点：进程自备同步操作，P/V操作大量分散在各个进程中，不易管理，易发生死锁</p>
<p>特点：</p>
<ul>
<li>管程内的数据只能由管程内的方法访问与操作，外部进程无法直接访问</li>
<li>每次仅允许一个进程在管程内执行某个方法</li>
<li>管程的互斥访问完全由编译程序在编译时自动添加，保证正确，不是进程无法被创建和撤销</li>
</ul>
<p>目的：</p>
<ul>
<li>把分散在各进程中的临界区集中起来进行管理</li>
<li>防止进程有意或无意的违法同步操作</li>
<li>便于用高级语言来书写程序，也便于程序正确性验证</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>产生的原因</strong></p>
<ul>
<li>互斥：进程对所需资源进行排它性控制</li>
<li>不剥夺：进程已经获得的资源不会被剥夺，只能自己主动释放</li>
<li>请求并保持：进程保持住了一个资源后，又对其它资源提出了请求</li>
<li>循环等待：进程之间循环等待资源释放</li>
</ul>
<p><strong>预防</strong></p>
<p>从破坏产生死锁的原因入手</p>
<ul>
<li>破坏互斥：不可行，有的资源必须互斥</li>
<li>强行剥夺：需要通过额外开销来保存现场，否则会导致进程前功尽弃。常用于易于保存和恢复现场的资源，如CPU的寄存器以及内存资源</li>
<li>破坏请求并保持：静态分配资源，进程运行前一次性占有它所需的所有资源。资源严重浪费</li>
<li>破坏循环等待：顺序资源分配法，系统没所有资源编号，每个进程只能按编号递增的顺序请求资源，阻止环的形成。编程麻烦</li>
</ul>
<p><strong>避免</strong></p>
<p>在资源动态分配的过程中，防止系统进入不安全状态</p>
<p>不安全状态不一定都会变成死锁，但安全状态一定没有死锁</p>
<p>什么是安全状态：有一堆进程，它们已占有了一些资源，系统还剩下一些资源，我如果能找到一个合适的顺序，按照这个顺序把资源依次分配给这些进程（每个进程结束会释放它占有的资源，所以资源数量随着进程的结束会越来越多），那么这个顺序就叫【安全序列】，当前处于安全状态</p>
<p>银行家算法</p>
<p>核心：多个进程，多个资源的 Need 矩阵，与当前可用资源向量 Available 的比较</p>
<p>思路：试探性的分配，如果分配后能找到安全序列，则此次分配安全，否则拒绝分配</p>
<p><strong>检测及解除</strong></p>
<p>资源分配图：</p>
<p><img src="/posts/operating-system/1575361736973.png" alt="1575361736973"></p>
<ul>
<li>大圆圈：代表一个进程</li>
<li>方块：一类资源</li>
<li>方块里的小圆圈：一个资源</li>
<li>进程到资源的箭头：请求边，进程正在请求一个该类资源</li>
<li>资源到进程的箭头：分配边，进程已拥有一个该类资源</li>
</ul>
<p><strong>死锁定理</strong>（检测）：资源分配图不可完全简化时，当前状态为死锁</p>
<p>资源图简化：找到能正常运行的进程，把该进程的出边和入边删除，直到所有的边被消去，则完全简化</p>
<p>死锁解除</p>
<ul>
<li>资源剥夺：抢占资源</li>
<li>撤销进程：按优先级撤销进程</li>
<li>进程回退：进程主动释放资源，要求保存进程历史信息，设置还原点</li>
</ul>
<hr>
<p>【例】系统产生死锁的原因可概括为</p>
<p>独占资源分配不当（√）</p>
<p>系统资源不足（×）资源不足导致的是饥饿，根本就跑不了</p>
<p>【例】”死锁“与”饥饿“的区别</p>
<p>答：死锁是相互的，是多个进程互相锁住，而饥饿是指单个进程因各种原因一直不能执行</p>
<hr>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="程序运行的步骤"><a href="#程序运行的步骤" class="headerlink" title="程序运行的步骤"></a>程序运行的步骤</h3><ul>
<li>编译：将源代码编译成目标文件，比如 .obj</li>
<li>链接：将目标文件与所需的库函数链接在一起，形成装入模块，<strong>产生整个程序完整的逻辑地址空间</strong>，产生 exe 文件<ul>
<li>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行程序，以后不再拆开。</li>
<li>装入时动态链接：在装入内存时，釆用边装入边链接的链接方式。</li>
<li>运行时动态链接：对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接。其优点是便于修改和更新，便于实现对目标模块的共享。</li>
<li>动态链接与程序的逻辑结构有关，所以段式存储有利于动态链接</li>
</ul>
</li>
<li><p>装入：双击exe，将装入模块调入内存运行</p>
<ul>
<li>绝对装入。在编译时，就知道程序将驻留在内存的哪个位置，产生绝对地址的目标文件。按照地址直接装入。<ul>
<li>这里程序中的逻辑地址与实际内存地址完全相同，故不需对程序和数据的地址进行修改。</li>
</ul>
</li>
<li>可重定位装入：又称为静态重定位，每个模块内部从 0 号单元开始编逻辑地址，将模块装入到内存的适当位置时，对目标程序中指令和数据重定位，地址变换通常是在装入时一次完成的。<ul>
<li>作业装入内存时，必须分配其要求的全部内存，如果内存不够，就不能装入</li>
<li>作业一旦进入内存，在整个运行期间不能在内存中移动，也不能再申请内存空间。</li>
</ul>
</li>
<li>动态运行时装入，也称为<u>动态重定位</u>，装入程序在把装入模块装入内存后，模块中还是相对地址，到程序真正要<strong>执行时</strong>才地址转换（动态重定位），这种方式需要<strong>一个</strong>重定位寄存器的支持。这种程序在装入后还可能被换出，所以同一模块的物理地址可能会变<ul>
<li>动态重定位的特点是可以将程序分配到不连续的存储区中；</li>
<li>在程序运行之前可以只装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；</li>
<li>便于程序段的共享，可以向用户提供一个比存储空间大得多的逻辑地址空间。</li>
</ul>
</li>
</ul>
</li>
<li><p>运行：需要界地址寄存器（包含最大逻辑地址）和重定位寄存器，首先界地址寄存器判断逻辑地址是否越界，若没越界则通过重定位寄存器计算得物理地址</p>
<ul>
<li>CPU调度程序选择进程执行时，派遣程序会初始化 界地址寄存器 和 重定位寄存器</li>
<li>动态重定位，地址转换</li>
</ul>
</li>
</ul>
<h3 id="覆盖和交换"><a href="#覆盖和交换" class="headerlink" title="覆盖和交换"></a>覆盖和交换</h3><p>覆盖：内存中有一个覆盖区，运行一个大型进程时，执行的部分调入内存的覆盖段，没执行的部分在外存。所以当正在运行的部分大于内存时，程序还是跑不了</p>
<p>交换：把处于等待状态或时间片刚过的程序从内存【换出】到外存，把另一个准备竞争CPU的进程【换入】</p>
<ul>
<li>磁盘上有一个交换区用于交换，这一区域独立于文件系统，使用起来可以很快</li>
<li>交换需要备份储存内存映像</li>
<li>换出的进程是完全处于空闲状态的</li>
</ul>
<h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><ul>
<li>单一连续分配：用于单用户单任务的系统中，内存分为系统区和用户区，一次就只有一个进程在用户区，啥算法都不要，简单，无外碎片，有内碎片，内存不够可以使用覆盖技术</li>
<li>固定分区分配：将用户区分成大小相等的或大小不等的许多小分区，每个进程占一块分区，这就衍生出了问题<ul>
<li>进程太大一个小区域放不下</li>
<li>进程太小没有放满一个分区【内碎片】，内存空间利用率低</li>
<li>进程装入后就不会改变位置了，可以采用静态重定位</li>
</ul>
</li>
<li>动态分区分配：并不事先划分好小分区，而是根据装入进程的大小动态建立分区。缺点很明显<ul>
<li>随着进程的换入换出，内存中会出现越来越多的小碎片【外碎片】，解决方式是”紧凑“，相对费时</li>
<li>使用 ”拼接技术“ 对空闲区合并，另外在紧凑会使得程序在运行过程中的地址发生变化</li>
<li>分配策略：当有多个合适的空闲块，选择哪一个块分配给将要进来的进程呢<ul>
<li>首次适应：地址递增的顺序查找，找到第一个即可【最好，最快的】【外碎片集中在低地址】</li>
<li>最佳适应：按容量递增，找到第一个合适的【外碎片最多】</li>
<li>最坏适应/最大适应：按容量递减的顺序，即找最大的</li>
<li>邻近适应：循环首次适应算法，从上次查找结束的位置开始继续查找 ”首次适应“【外碎片集中在内存的末尾】</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>【例】分区分配内存管理方式的主要保护措施是（A）</p>
<p>A：界地址保护</p>
<p>B：程序代码保护</p>
<p>C：数据保护</p>
<p>D：栈保护</p>
<hr>
<h3 id="非连续分配"><a href="#非连续分配" class="headerlink" title="非连续分配"></a>非连续分配</h3><h4 id="页式"><a href="#页式" class="headerlink" title="页式"></a>页式</h4><p>把进程和内存都分成相同大小的块，进程中的块称为页 page，内存中的块称为页框 page frame，页与页框对应。会产生页内碎片，但无外碎片</p>
<p>每个进程会有一张页表，页表项记录了该进程逻辑页号所对应的物理块号。要覆盖全部逻辑地址的页</p>
<p>逻辑地址由页号和页内位移组成</p>
<ul>
<li>页号是页表中的页表项的号，页表项里面是物理地址的页框号</li>
<li>页内位移是页框内的位移，具体字节</li>
</ul>
<p><img src="/posts/operating-system/1575372756493.png" alt="1575372756493"></p>
<p>20位的页号表示逻辑地址页数为$2^{20}$，页表项的大小至少是20位（3B，通常取4B），12位的页内偏移表示页的大小为$2^{12}$Bytes。</p>
<p>主存储器的访问以字节为单位</p>
<p>根据逻辑地址取一个数或一条指令要两次访存</p>
<ul>
<li>第一次访问页表</li>
<li>第二次根据物理地址访问块</li>
</ul>
<p>优化：增设一个高速缓冲器——快表（TLB）快表不在内存中。如果命中快表，就直接拼接物理地址访问块，一次访存即可</p>
<p><img src="/posts/operating-system/1575370452737.png" alt="1575370452737"></p>
<p>二级页表</p>
<p>就上述32位逻辑地址，12位页内偏移，一页4K，其一级页表本身有 $2^{20}$ = 1M 页表项，即页表有4M = 1K页，挺大的，能不能为这1K 个页再建一个页表，于是乎二级分页出来了</p>
<p>如何划分二级分页逻辑地址结构呢？</p>
<ul>
<li><p>首先有一个规则是多级分页中的顶级页表最多占一个页框</p>
</li>
<li><p>在这里一个页框 4KB，一个页表项是 4B，所以二级页表最多有 1K 个页表项，即通过二级页表可以索引 1K 个一级页表。所以一级页号要有 10 位，用来定位一级页表所在的框</p>
</li>
<li>找到了一级页表所在的页框后，就要进一步找到这个一级页表里面的页表项，因为这个页表项里面有正式的物理块号。那么一个页框 4KB，即 1K 个页表项，所以还需要 10 位的二级页号来定位页表项</li>
<li>10 + 10 + 12 = 32 完美~</li>
</ul>
<p><img src="/posts/operating-system/1575374982183.png" alt="1575374982183"></p>
<p><img src="/posts/operating-system/1575375028443.png" alt="1575375028443"></p>
<hr>
<p>【例】页表的起始地址放在（B）中</p>
<p>A：内存</p>
<p>B：寄存器</p>
<p>解释：页表的功能由一组专门的存储器实现，其始地址放在页表基址寄存器（PTBR）中，快速完成地址映射</p>
<p>【例】操作系统采用分页式管理时，要求（A）</p>
<p>A：每个进程一张页表，且进程的页表留在内存中</p>
<p>B：每个进程一张页表，且只有执行进程的页表留在内存中</p>
<p>多进程并发执行时，系统中只设置一个页表寄存器（PTR），存放页表在内存中的始地址和长度。进程未执行时，页表的始地址和长度放在PCB中，当进程被调度执行时，才把这两个数据调入PTR</p>
<hr>
<h4 id="段式"><a href="#段式" class="headerlink" title="段式"></a>段式</h4><p>分页通过硬件机制实现，对用户完全透明</p>
<p>分段方式在用户编程时就确定了</p>
<p>物理上：段间离散，段内连续【没有内碎片，有外碎片】；给出的逻辑地址是二维的【段号，段内位移】</p>
<p>段表项两个内容</p>
<ul>
<li>段长：这个段的长度</li>
<li>物理基址：这个段在内存的地址</li>
</ul>
<p>两个越界检查</p>
<ul>
<li>段号要小于段表长</li>
<li>端内位移要小于段长</li>
</ul>
<p><strong>段的共享</strong>：不能修改的代码称为【纯代码】或【可重入代码】不属于临界资源</p>
<h4 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h4><p>页式：有效利用内存</p>
<p>段式：反映程序逻辑结构，有利于段的共享</p>
<p>段页式</p>
<ul>
<li>程序分段，段内分页；一个程序一个段表，每个段一个页表</li>
<li>内存分页</li>
</ul>
<p>逻辑地址结构：【段号S + 页号P + 页内偏移W】</p>
<p>地址映射过程</p>
<ul>
<li>根据段号在程序的段表中查找到 S 号段表项，这个段表项里有 S 段的页表首地址</li>
<li>根据找到的页表首地址 + 页号P 得到 P号页表项，页表项里有物理块号</li>
<li>合并找到的物理块号 和 页内偏移W 得到最终物理地址</li>
<li>3 次访存</li>
</ul>
<p>优化：快表【段号，页号，页帧号，保护码】</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>操作系统将暂时不用的内容换出到外存上，把要用的页调进内存的<strong>驻留集</strong>中，这样系统好像为用户提供了一个比实际内存大的存储器。存储器的大小由系统的地址结构决定。</p>
<p>允许作业在运行过程中，进行换进和换出</p>
<p>实现方法：在之前的分页、分段、段页式的基础上增加了【请求调页】功能和【页面置换】功能，基本手段就是【覆盖】与【交换】</p>
<p>新页表项结构如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>物理块号</th>
<th>状态位P/合法位</th>
<th>访问字段A</th>
<th>修改位M</th>
<th>外存地址</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>该页是否在内存，为 0 缺页</td>
<td>访问次数或未访问的时间</td>
<td>是否修改</td>
<td>调入该页时，参考</td>
</tr>
</tbody>
</table>
</div>
<p>请求访问某一页的基本过程</p>
<ul>
<li>CPU检索快表，若命中快表，修改访问位（写指令：和修改位），合并物理地址，万事大吉</li>
<li>该页不在快表里，就访问内存，若在内存里，更新快表，修改访问位（写指令：和修改位），合并物理地址</li>
<li>内存里也没有这个页，产生缺页中断，保存CPU现场，转入缺页中断处理程序：<ul>
<li>从外存中找到该页，若内存未满，启动IO，将该页调入内存，修改页表，回到最初的起点，检索快表</li>
<li>若内存满了，就要【选择内存中的一页换出 ①】，如果要换出的页被修改过了，则将该页写回外存</li>
<li>没被修改过，则直接启动IO，将该页调入内存将它覆盖掉，修改页表，回到最初的起点，检索快表</li>
</ul>
</li>
</ul>
<p><strong>页面置换算法</strong>：选择内存中的哪一页换出，缺页中断处理过程的一个环节</p>
<ul>
<li>Optimal（OPT）：选择最长时间内不再被访问的页面，理想最佳情况，用来评价其它置换算法</li>
<li>FIFO：选驻留时间最久的页。【有Belady异常：当分配的物理块变多，缺页次数不减反增】</li>
<li>LRU：过去一段时间最久没有被访问过的页面，降低缺页率方面表现较好，要寄存器和栈的硬件支持，是堆栈类算法【堆栈类算法不会有Belady异常】，但每次调页都需要对所有的页进行排序，消耗高</li>
<li>时钟（CLOCK）置换：又称为最近未用（NRU）<ul>
<li>将所有帧围成一个圈，每个帧有一个使用位 u，刚进入的新帧 u = 1</li>
<li>请求一个页，命中的话，把圈圈里的这个页的 u = 1，其它屁事没有</li>
<li>否则的话，缺页中断处理，开始转动罪恶的指针，指针经过的帧如果 u == 1的话，u就变成0，如果 u是0的话，那就它了，换入的页就占这个位置，然后<strong>指针往后移动一位</strong></li>
</ul>
</li>
<li>改进后的（CLOCK）：在考虑了使用与未使用的基础上，还考虑了修改与未修改，由于每次替换已修改的页都需要写回，所以在未使用的页里，优先选择调出未修改的页。再添加一个修改位 m = 0，发生修改时 m = 1<ol>
<li>缺页处理时，先转一圈，挑出遇到的第一个 u=0, m=0 的崽，就它了</li>
<li>如果挑不出这样的，再转罪恶之第二圈，抓到一个 u=1，m=0 的崽，转这圈时，指针经过的帧 u == 1都变成0</li>
<li>如果还是找不到，没事，这时圈里只会有(u=0, m=0)和( u=0，m=1)的崽，再回到第 1 步即可</li>
</ol>
</li>
</ul>
<p><strong>比较</strong>：LRU要维持一个线型链表，要改动结构，而NRU维持一个稳定的环状，改动的只是一个使用位，代价更低</p>
<p><strong>驻留集分配策略</strong></p>
<ul>
<li>固定分配局部置换：每个进程固定数量的物理块</li>
<li>可变分配全局置换：每个进程初始分配物理块，运行时每次缺页，从系统中分配一个块加进去</li>
<li>可变分配局部置换：每个进程初始分配物理块，运行时当缺页率过高，就从系统中加一个块进去，当缺页率过低，则可以减少该进程的物理块</li>
</ul>
<p><strong>两种调页时机</strong></p>
<ul>
<li><p>请求调页：运行时一次只调入一页</p>
</li>
<li><p>预调页：运行前一次调入若干相邻页</p>
</li>
</ul>
<p>通常两种方式一起使用</p>
<p><strong>从哪里调页</strong> —— 外存 = 交换区 + 文件区</p>
<p>交换区是连续分配的方式，文件区是离散分配，所以交换区的磁盘I/O更快</p>
<ul>
<li>系统有足够的交换区，那么在程序运行前，就需要将与程序有关的文件全复制到交换区</li>
<li>系统交换区不够：对于没有被修改过的页，直接从文件系统调入，调入后被修改了，那调出时要调到交换区内。</li>
</ul>
<p><strong>抖动</strong>：<u>某个程序频繁访问的页面</u>数，多于可用的物理块数，则不得不频繁的进行页面的换入换出，占用大量CPU时间，这就叫抖动，所有的页面置换算法都不能避免抖动</p>
<p>某个程序频繁访问的页面叫【工作集】，所以如果不想发生抖动，分配给进程的驻留集要大于工作集</p>
<p>【工作集】的确定：由 时间 t 和 工作集窗口大小 S 确定，将 S 内的所有的页去重就得到 工作集</p>
<p>比如：t 时刻，S 中的内容是[ 2，3，5，3，2]，则工作集为{2，3，5}</p>
<p>虚存本质是利用外存上的空间来扩充内存，所以【虚存大小 ≤ 内存 + 外存】，此外虚存还受逻辑地址位数限制</p>
<hr>
<p>【例】用户进程缺页处理时可能会执行哪些操作</p>
<ul>
<li>处理越界（×）缺页是在检查页表的时候，发现这个页对应的表项的有效位是 0，即这个页不在内存中，这时在外存里找这个页，并不需要越界处理</li>
<li>置换页（√）</li>
<li>分配内存（√）</li>
</ul>
<p>【例】某一计算机，CPU利用率长期在20%左右，而磁盘利用率却经常达到90%以上，其它设备利用率5%，如何永久提高该计算机的性能</p>
<p>答：CPU是用来跑进程的，CPU利用率低说明主要时间耗费在IO上，而此时并没有过多的外设负载，因此该计算机在进程不多的情况下，交换非常频繁，此时可以加一根内存条来降低缺页率</p>
<p>PS：如果想暂时提高，减少多道程序的数量也行，每个进程分配到的空间就更多</p>
<p>另外：如果换一个性能更好的磁盘（交换区速度更快），其实并没有用，这并不会降低缺页率，调入调出的频率由CPU决定，与交换区速度无关；那如果换一个性能强悍的CPU呢，也无济于事，目前这个CPU的利用率都只有20%，你换强悍的CPU除了在面板上降低了CPU利用率之外，没卵用，该缺页缺页，调页所占的时间比例都不变的</p>
<p>正常情况下：CPU利用率应该远大于磁盘利用率</p>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>以进程为基本单位作资源调度与分配，以文件为基本单位输入输出</p>
<p>文件系统 = 管理文件的软件 + 被管理的文件 + 实施管理时需要的数据结构</p>
<p>文件系统的两大任务</p>
<ul>
<li>上对用户：让用户按名存储，查找文件，组织成合适的结构，并提供对文件的基本操作</li>
<li>下对磁盘：完成文件的逻辑结构到物理结构的映射，组织文件在磁盘上的存放，提供好的调度方法维持好性能</li>
</ul>
<p>文件的两大逻辑结构（对用户而言）</p>
<ul>
<li>有结构文件：也叫记录式文件（比如学生信息记录<ul>
<li>顺序文件：定长记录顺序存放（比如磁带</li>
<li>索引文件：为可变长的所有记录建立索引表，索引表本身是顺序存储的</li>
<li>顺序索引文件：将所有记录分组，每个组一个索引，且组与组之间的关键字必须有序排列，组内记录可以无序。顺序查找索引表，再顺序查找组内记录</li>
<li>哈希文件：物理地址 = hash(address)</li>
</ul>
</li>
<li>无结构文件：也叫流式文件，以字节为单位比如二进制文件，字符文件</li>
</ul>
<p><strong>目录结构</strong></p>
<p>所有的文件信息都在目录结构中，而目录结构在外存中，只有在被需要的时候才调入内存</p>
<p>FCB：文件控制块，通常有基本信息（文件名等）、存取控制信息及使用信息。FCB的有序集就是文件目录，FCB就是目录项</p>
<p>用户按名查找文件时，要将文件目录调入内存进行比对，而通常文件信息较大，所以UNIX提出了分离文件名和文件信息的方案，调入内存的目录结构的目录项仅有【文件名+指向文件信息的指针】，用一个一个索引节点 inode 来存放文件信息，文件在磁盘上的物理地址就在这个文件信息里</p>
<p>种类</p>
<ul>
<li>单级目录结构：</li>
<li>两级目录结构：</li>
<li>多级（树形）目录结构<ul>
<li>实现文件分类，但不能实现文件共享</li>
<li>按路径名查找文件时要逐级访问中间节点</li>
<li>进程对各文件的访问都是相对于当前目录进行的，可以加快文件检索速度</li>
</ul>
</li>
<li>无环图目录结构：实现文件共享，每个被共享的文件有一个引用计数器。<ul>
<li>被共享的文件本身不能随意删除</li>
<li>含有被其他目录共享的文件的目录也不能随意删除</li>
</ul>
</li>
</ul>
<p><strong>文件共享</strong></p>
<ul>
<li>硬链接：两个文件目录项指向同一个索引节点 inode，要比软链接更快。<ul>
<li>引用计数+1</li>
<li>删除的时候不能直接删文件，要检查引用计数，引用计数 -1</li>
</ul>
</li>
<li>软链接：符号链接，包含被共享文件的路径名，包括网络共享。<ul>
<li>引用计数直接复制</li>
<li>看不见删除操作，发现路径下找不到文件，就直接删了这个软链接</li>
</ul>
</li>
</ul>
<p><strong>打开文件</strong></p>
<p>每个进程的PCB中有自己打开文件的文件描述符表，每个文件描述符指向一个”对文件的打开“，即open-file-table里的一项，这一项中有读/写状态以及当前的读/写偏移（位置）</p>
<hr>
<p>【例】UNIX把所有设备都视为（特殊的文件）</p>
<p>【例】打开文件的操作是（A）</p>
<p>A：把文件目录复制到内存</p>
<p>B：把文件复制到内存</p>
<p>解释：首次打开文件的时候，是把FCB存到内存中的活跃文件目录表</p>
<p>【例】关于进程进行read系统调用的过程的叙述正确的是</p>
<p>A：若该文件的数据不在内存，则该进程进入睡眠等待状态（√ 缺页中断嘛）</p>
<p>B：调用过程中，CPU会切换至核心态（√ 系统调用嘛）</p>
<p>C：read系统调用的参数包含文件名（×）</p>
<p>解释：read 之前要 open 一个文件，open 需要路径名和文件名，随后会返回一个文件描述符 fd。接着再 read 这个文件，这时候的参数是 fd，buf首地址，字节数n。文件名只有在第一次open的时候才有</p>
<p>【例】文件系统中有四类用户，五类权限，则FCB中描述不同类别的用户对一个文件的访问权限需要多少二进制位数？</p>
<p>答：矩阵，4 × 5 = 20 位</p>
<p>【例】提高文件访存速度的方法有</p>
<ul>
<li>提前读（√）：在读取当前块时，就将下一个可能要访问的盘块读入缓冲区</li>
<li>延迟写（√）：先将数据写入缓冲区，不急着写回磁盘，后续再访问会快一些，只有在缓冲区被分配出去才写回磁盘</li>
</ul>
<hr>
<h3 id="物理分配方式"><a href="#物理分配方式" class="headerlink" title="物理分配方式"></a>物理分配方式</h3><ul>
<li>连续分配：访问磁盘的寻道数和寻道时间最小<ul>
<li>不宜动态增加，支持直接访问，顺序访问时速度最快</li>
<li>有外碎片</li>
<li>目录中有【name，start，length】</li>
</ul>
</li>
<li>链接分配：无外碎片<ul>
<li>隐式：每个盘块都有指向下一个盘块的指针<ul>
<li>一个块坏了，整个文件就报废了</li>
<li>目录中有【name，start，end】</li>
</ul>
</li>
<li>显式：整个磁盘设置一张表（FAT文件分配表）表项存放着对应块的下一块的指针<ul>
<li>在内存中进行查找，速度快</li>
<li>支持直接访问</li>
</ul>
</li>
</ul>
</li>
<li>索引分配：把每个文件的所有块号放在一起构成索引块<ul>
<li>目录中有【name，索引块号】</li>
<li>可以构成多级索引</li>
<li>随机访问时速度最快，动态扩展</li>
</ul>
</li>
</ul>
<hr>
<p>【例】支持视频文件的快速随机播放，则性能最好的文件数据块组织方式是（A）</p>
<p>A：连续结构</p>
<p>B：多级索引</p>
<p>解释：快速随机播放要最短的查询时间</p>
<p>【例】有一记录文件，一条记录长度为100B，采用链接分配方式，盘块长度为512B。若该文件的目录项已经读入内存，则对第22个记录完成修改并保存后，共启动了几次磁盘？</p>
<p>答：22×100/512 = 4 余 152，即这条记录在第五块，按链接依次启动五次磁盘，此时记录被加载到内存中，同时第五块的物理地址也被记录下来，记录修改后，还要写回，这次直接访问第五块，再启动一次磁盘即可。</p>
<p>所以是 5 + 1 = 6（次）</p>
<hr>
<h3 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h3><ul>
<li><p>空闲表法</p>
</li>
<li><p>空闲链表法</p>
</li>
<li><p>位图法：二进制的一位表示一块，”1“已分配，”0“空闲</p>
</li>
<li><p>成组链接法：空闲表法+空闲链表法；适合大文件系统</p>
<p>  <img src="/posts/operating-system/1575463704209.png" alt="1575463704209"></p>
</li>
</ul>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>每个扇区固定容量大小，固定圆心角，所以磁盘的存储能力受限于最内道的最大记录密度</p>
<p>磁盘上的文件以【块】为单位进行读写</p>
<p>磁盘读写时间由以下几个部分组成</p>
<ul>
<li>寻道时间：跨越 n 条磁道 + 启动磁头</li>
<li>延迟时间：定位到扇区的时间 = 旋转半周的时间</li>
<li>传输时间：读出数据或写入数据的时间 = （这次读写的字节数/磁道上的字节数）×一圈的时间</li>
</ul>
<p><strong>磁盘调度算法</strong>：缩短寻道时间</p>
<ul>
<li>FCFS：先来先服务，与随机调度等价，不会产生【磁臂黏着】</li>
<li>SSTF：选择与当前磁头最近的磁道，会产生饥饿现象</li>
<li>SCAN：扫描/电梯调度算法：选择当前磁头移动方向上，与当前磁头最近的磁道，初始方向为向最近磁道<ul>
<li>对最近扫描过的区域不公平，因此局部性不好</li>
</ul>
</li>
<li>C-SCAN循环扫描：磁头单向移动提供服务，到最外或最里的磁道时立即退回到起始端，退回过程不提供服务，然后再和之前一样扫过去<ul>
<li>优化：不需要跑到盘面的端点，只要跑到序列中最远的磁道就可以退回了</li>
</ul>
</li>
</ul>
<h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><h3 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h3><ul>
<li>程序直接控制：忙等待好吧，浪费CPU</li>
<li>中断驱动：I/O设备一有破事儿就中断一下CPU，IO控制器与存储器传输的每个字都要经过CPU</li>
<li>DMA：在IO控制器与存储器之间直接开辟数据通路，解放CPU。有一个DMA控制器，即CPU的秘书，CPU只负责传输开始时启动秘书，告诉秘书【传输多少数据块以及把数据传输到哪里】，剩下的交给他，然后传输完成后，秘书过来通知一下CPU即可<ul>
<li>基本单位是数据块</li>
<li>一个DMA对应一台设备</li>
</ul>
</li>
<li>通道：CPU的儿子，也是一个低端”CPU“与它爹共享内存，CPU一次性把一组数据的传输任务交给通道，高速通道【跟哪个I/O设备打交道】，其它的就交给他仔了。<ul>
<li>可以实现CPU，I/O，通道三者的并行操作</li>
<li>一个通道对应多台设备</li>
</ul>
</li>
</ul>
<hr>
<p><img src="/posts/operating-system/image-20191210190654239.png" alt="image-20191210190654239"></p>
<p>【解释】用户程序对 I/O 设备的请求采用逻辑设备名，而在程序实际执行时使用物理设备名。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/posts/operating-system/" data-id="ckju61vq8000a7grr9qkgex88" data-title="操作系统" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/408-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88-%E8%80%83%E7%A0%94-OS/" rel="tag">408 计算机基础综合 考研 OS</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/posts/computer-network/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          计算机网络
        
      </div>
    </a>
  
  
    <a href="/posts/data-structure/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">数据结构</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/408-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88-%E8%80%83%E7%A0%94/" rel="tag">408 计算机基础综合 考研</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/408-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88-%E8%80%83%E7%A0%94-OS/" rel="tag">408 计算机基础综合 考研 OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/408-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88-%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">408 计算机基础综合 考研 数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/408-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88-%E8%80%83%E7%A0%94-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">408 计算机基础综合 考研 计算机网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/408-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88-%E8%80%83%E7%A0%94/" style="font-size: 10px;">408 计算机基础综合 考研</a> <a href="/tags/408-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88-%E8%80%83%E7%A0%94-OS/" style="font-size: 10px;">408 计算机基础综合 考研 OS</a> <a href="/tags/408-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88-%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">408 计算机基础综合 考研 数据结构</a> <a href="/tags/408-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88-%E8%80%83%E7%A0%94-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">408 计算机基础综合 考研 计算机网络</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/posts/computer-organization/">计算机组成原理</a>
          </li>
        
          <li>
            <a href="/posts/computer-network/">计算机网络</a>
          </li>
        
          <li>
            <a href="/posts/operating-system/">操作系统</a>
          </li>
        
          <li>
            <a href="/posts/data-structure/">数据结构</a>
          </li>
        
          <li>
            <a href="/posts/hello-world/">建站过程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>